sst5 <- sum((winetest[1:2]-mean(winetrain))^2)
sse5 <- sum((wineprediction5[1:2]-winetest$LPRICE[1:2])^2)
sst5 <- sum((winetest$LPRICE[1:2]-mean(winetrain$LPRICE))^2)
1-sse5/sst5
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
sp <- read.csv("socprog2020.csv")
str(sp)
any(is.na(sp))
colSums(which(is.na(sp))
colSums((which(is.na(sp))
colSums(is.na(sp)
colSums(is.na(sp))
sum(is.na(sp))
str(sp)
colSums(is.na(sp))
colSums(is.na(sp))
sp[rowSums(is.na(sp))>0,]
str(sp)
head(sp)
dim(sp)
sp <- read.csv("socprog2020.csv")
str(sp)
any(is.na(sp))
sum(is.na(sp))
colSums(is.na(sp))
sp[rowSums(is.na(sp))>0,]
head(sp)
dim(sp)
head(sp)
sp2020 <- subset(sp,sp$SPI.year=="2020" & sp$Status=="Ranked")
rownames(sp2020) <- sp2020[,2]
spirank <- sp2020[,1]
sp2020 <- sp2020[6:]
dim(sp)
sp2020 <- sp2020[6:71]
head(sp2020)
sp2020 <- sp2020[-c(1:6)]
sp <- read.csv("socprog2020.csv")
sp2020 <- subset(sp,sp$SPI.year=="2020" & sp$Status=="Ranked")
rownames(sp2020) <- sp2020[,2]
spirank <- sp2020[,1]
sp2020 <- sp2020[-c(1:6)]
head(sp2020)
dim(sp2020)
sp <- read.csv("socprog2020.csv")
str(sp)
any(is.na(sp))
sum(is.na(sp))
colSums(is.na(sp))
sp[rowSums(is.na(sp))>0,]
head(sp)
dim(sp)
sp2020 <- subset(sp,sp$SPI.year=="2020" & sp$Status=="Ranked")
rownames(sp2020) <- sp2020[,2]
spirank <- sp2020[,1]
sp2020 <- sp2020[-c(1:6)]
dim(sp2020)
sprank <- sp2020[,1] #Set rank
sp <- read.csv("socprog2020.csv")
str(sp)
any(is.na(sp))
sum(is.na(sp))
head(sp)
dim(sp)
sp2020 <- subset(sp,sp$SPI.year=="2020" & sp$Status=="Ranked")  #filter to only 2020 and ranked countries
rownames(sp2020) <- sp2020[,2]  #Set rowname as country
sprank <- sp2020[,1] #Set rank
sp2020 <- sp2020[-c(1:6)]
dim(sp2020)
rm(spirank)
dim(sp2020)
dim(sp2020)
sp20201 <- na.omit(sp2020)
sp20201
dim(sp20201)
dim(sp)
sp <- read.csv("socprog2020.csv")
str(sp)
any(is.na(sp))
sum(is.na(sp))
head(sp)
dim(sp)
sp2020 <- subset(sp,sp$SPI.year=="2020" & sp$Status=="Ranked")  #filter to only 2020 and ranked countries
rownames(sp2020) <- sp2020[,2]  #Set rowname as country
sprank <- sp2020[,1] #Set rank
sp2020 <- sp2020[-c(1:6)]
dim(sp2020)
sp2020
dim(sp)
dim(sp2020)
sp2020
dim(sp2020)
sp2020
NAobject <- colnames(sp2020)[apply(is.na(sp2020),2,any)]
sp2020 <- sp2020[,!names(sp2020)%in%NAobject]
dim(sp2020)
head(sp2020)
sp2020["Singapore"]
sp2020["Singapore",]
sp2020["Singapore",]
sp2020["United States",]
summary(sp2020$Basic.Human.Needs)
sp2020["Singapore",]
sp2020["United States",]
summary(sp2020$Basic.Human.Needs)
which(max(sp2020$Basic.Human.Needs))
max(sp2020$Basic.Human.Needs)
which(sp2020=max(sp2020$Basic.Human.Needs))
which(rownames=max(sp2020$Basic.Human.Needs))
which.max(sp2020$Basic.Human.Needs)
sp2020[68,]
which.max(sp2020$Basic.Human.Needs)-1
sp2020[67,]
sp2020$Basic.Human.Needs
sp2020
View(sp20201)
View(sp20201)
View(sp2020)
View(sp2020)
which.max(sp2020$Basic.Human.Needs)
sp2020[68,]
summary(sp2020$Basic.Human.Needs)
sp2020[which.max(sp2020$Access.to.Basic.Knowledge),]
names(sp2020)
rm(sp20201)
stats <- cbind(apply(sp2020),2,mean),
stats <- cbind(apply((sp2020),2,mean)),
apply((sp2020),2,mean)
apply((sp2020),3,mean)
apply((sp2020),1,mean)
apply((sp2020),1,mean)
apply((sp2020),2,mean)
apply((sp2020),2,mean)
stats <- cbind(apply((sp2020),2,mean),apply(sp2020,2,"median"),apply(sp2020,2,sd)
stats <- cbind(apply((sp2020),2,mean),apply(sp2020,2,"median"),apply(sp2020,2,sd))
stats <- cbind(apply((sp2020),2,mean),apply(sp2020,2,"median"),apply(sp2020,2,"sd""))
stats <- cbind(apply((sp2020),2,mean),apply(sp2020,2,"median"),apply(sp2020,2,"sd"")
stats <- cbind(apply((sp2020),2,mean),apply(sp2020,2,"median"),apply(sp2020,2,"sd""))
stats <- cbind(apply((sp2020),2,mean),apply(sp2020,2,"median"),apply(sp2020,2,"sd"))
stats <- cbind(apply(sp2020,2,mean),apply(sp2020,2,"median"),apply(sp2020,2,"sd"))
stats
dim(stats)
stats
stats <- cbind(apply(sp2020,2,mean),apply(sp2020,2,"sd"))
stats
stats <- cbind(apply(sp2020,2,mean),apply(sp2020,2,"median"), apply(sp2020,2,"sd"))
stats
stats <- cbind(apply(sp2020,2,mean),apply(sp2020,2,"median"),apply(sp2020,2,"sd"))
stats
stats <- cbind(apply(sp2020,2,mean),apply(sp2020,2,"median"),apply(sp2020,2,"sd"))
stats
View(stats)
stats
View(stats)
pr.out.ns
pr.out.ns=prcomp(sp2020, scale=F)  #
pr.out.ns
mtcars <- colnames(mtcars)[apply(is.na(mtcars),2,any)]
#Remove columns with NA value, not removing cars, 2 indicates columns
mtcars <- mtcars[,!names(mtcars)%in%NAobject]
mtcars
mtcars
str(mtcars)
mtcars
mtcar
mtcars
mtcars
data(mtcars)
mtcars
dim(mtcars)
mtcars <- colnames(mtcars)[apply(is.na(mtcars),2,any)]
#Remove columns with NA value, not removing cars, 2 indicates columns
mtcars <- mtcars[,!names(mtcars)%in%NAobject]
NAobject <- colnames(mtcars)[apply(is.na(mtcars),2,any)]
#Remove columns with NA value, not removing cars, 2 indicates columns
mtcars <- mtcars[,!names(mtcars)%in%NAobject]
data(mtcars)
dim(mtcars)
NAobject <- colnames(mtcars)[apply(is.na(mtcars),2,any)]
#Remove columns with NA value, not removing cars, 2 indicates columns
mtcars <- mtcars[,!names(mtcars)%in%NAobject]
dim(mtcars)
data(mtcars)
dim(mtcars)
data(mtcars)
dim(mtcars)
NAobject <- colnames(mtcars)[apply(is.na(mtcars),2,any)]
#Remove columns with NA value, not removing cars, 2 indicates columns
mtcars1 <- mtcars[,!names(mtcars)%in%NAobject]
dim(mtcars1)
mtcars[33,] <- c(NA)
mtcars
NAobject <- colnames(mtcars)[apply(is.na(mtcars),2,any)]
#Remove columns with NA value, not removing cars, 2 indicates columns
mtcars1 <- mtcars[,!names(mtcars)%in%NAobject]
dim(mtcars1)
pr.out.ns$x[1:10,1:5]  #show PCA scores for first 10 countries for the first 5 PCs
pr.out.ns
plot(pr.out.ns,type="l", main="Scree plot")
pr.out.ns  #Sd you get is the sqrt(var) where var is the eigenvalues for the PCA
pr.var.ns=pr.out.ns$sdev^2
plot(cumsum(pve.ns),xlab="Prinicpal Component", ylab = "Cumulative Proportion of Variance Explained", ylim = c(0,1),type = 'b')+abline(h=0.9,col="red")
pr.var.ns=pr.out.ns$sdev^2
pve.ns=pr.out.ns$sdev/sum(pr.out.ns$sdev^2)
plot(cumsum(pve.ns),xlab="Prinicpal Component", ylab = "Cumulative Proportion of Variance Explained", ylim = c(0,1),type = 'b')+abline(h=0.9,col="red")
pr.var.ns=pr.out.ns$sdev^2
pve.ns=pr.out.ns$sdev^2/sum(pr.out.ns$sdev^2)
plot(cumsum(pve.ns),xlab="Prinicpal Component", ylab = "Cumulative Proportion of Variance Explained", ylim = c(0,1),type = 'b')+abline(h=0.9,col="red")
plot(pr.out.ns,type="l", main="Scree plot")  # type="l" is line, shows how much of var is attributed to each PC
plot(pr.out.ns,type="l", main="Scree plot")  # type="l" is line, shows how much of var is attributed to each PC
#Next lines is to do a cumulative variance plot
pr.var.ns=pr.out.ns$sdev^2
pve.ns=pr.out.ns$sdev^2/sum(pr.out.ns$sdev^2)
plot(cumsum(pve.ns),xlab="Prinicpal Component", ylab = "Cumulative Proportion of Variance Explained", ylim = c(0,1),type = 'b')+abline(h=0.9,col="red")
#Next lines is to do a cumulative variance plot
pr.var.ns=pr.out.ns$sdev^2
pve.ns=pr.out.ns$sdev^2/sum(pr.out.ns$sdev^2)
plot(cumsum(pve.ns),xlab="Prinicpal Component", ylab = "Cumulative Proportion of Variance Explained", ylim = c(0,1),type = 'b')+abline(h=0.9,col="red")
plot(pr.out.ns,type="l", main="Scree plot")  # type="l" is line, shows how much of var is attributed to each PC
#Next lines is to do a cumulative variance plot
pr.var.ns=pr.out.ns$sdev^2
pve.ns=pr.out.ns$sdev^2/sum(pr.out.ns$sdev^2)
plot(cumsum(pve.ns),xlab="Prinicpal Component", ylab = "Cumulative Proportion of Variance Explained", ylim = c(0,1),type = 'b')+abline(h=0.9,col="red")
pve.ns[1]
plot(pr.out.ns,type="l", main="Scree plot")  # type="l" is line, shows how much of var is attributed to each PC
#Next lines is to do a cumulative variance plot
pr.var.ns=pr.out.ns$sdev^2
pve.ns=pr.out.ns$sdev^2/sum(pr.out.ns$sdev^2)
plot(cumsum(pve.ns),xlab="Prinicpal Component", ylab = "Cumulative Proportion of Variance Explained", ylim = c(0,1),type = 'b')+abline(h=0.9,col="red")
pve.ns[1]
stats
View(stats)
sp.pc <- data.fram(pr.out.ns$x[,1:2])
sp.pc <- data.frame(pr.out.ns$x[,1:2])
View(pr.out.ns)
sp.pc <- data.frame(pr.out.ns$x[,1:2])
sp.pc[order(-sp.pc$PC1),]
sp.pc[order(-sp.pc$PC2),]
dim(sp2020)
co.sp.pc <- data.frame(pr.out.ns$rotation[,1:2])
co.sp.pc[order(-co.sp.pc[,1]),][c(1:5,50:54),]
co.sp.pc[order(-co.sp.pc[,2]),][c(1:5,50:54),]
sp.pc <- data.frame(pr.out.ns$x[,1:2])
sp.pc[order(-sp.pc$PC1),]
sp.pc[order(-sp.pc$PC2),]
sp.pc[order(-sp.pc$PC2),]
sp.pc[order(-sp.pc$PC1),]
sp.pc <- data.frame(pr.out.ns$x[,1:2])
sp.pc[order(-sp.pc$PC1),]
sp.pc[order(-sp.pc$PC2),]
dim(sp2020)
co.sp.pc <- data.frame(pr.out.ns$rotation[,1:2])
co.sp.pc[order(-co.sp.pc[,1]),][c(1:5,50:54),]
co.sp.pc[order(-co.sp.pc[,2]),][c(1:5,50:54),]
ct <- c("jap","kor","sin","kor","jap","sin","sin") #Make a list
class(ct)  #Class is characters
fct <- factor(ct) #Turn the items into factors
fct    #See the item as well as levels of factor
levels(fct)  #See the headers/levels for the factors
fct <- factor(fct, levels=c("jap","kor")) #Filter the levels of interest
fct
summary(fct)  #See the headers/levels and how many items corr to them
table(fct)    #Returns same as summary
#Converting Class of Factors
X <- factor(c(4,5,6,6,4))
X <- as.character(X)  #Need to convert to character before numeric
X
X <- as.numeric(X)
X
summary(X)
#tapply
```{r}
income <- c(500,1000,4000,1244,3400,2000,5000)
mean(income)
tapply(income,fct,mean)
med <- data.frame(patient=1:100, age=rnorm(100, mean=60,sd=12),treatment=gl(4,25,labels=c("treatment","control","new","old")))
View(med)
med
tapply(med$age,med$treatment,mean)
tapply(med$age,med$treatment,mean)
income <- c(500,1000,4000,1244,3400,2000,5000)
mean(income)
tapply(income,fct,mean)
#tapply format(data, a list of factors same length),function)
med <- data.frame(patient=1:100, age=rnorm(100, mean=60,sd=12),treatment=gl(4,25,labels=c("treatment","control","new","old")))
#Creates a dataframe of 100 patients, with age being random normally distributed, with treatment (general label) 4 labels of 25
med
tapply(med$age,med$treatment,mean)
#Find mean of age sorted by treatment type
# (Shortcut to run chunk Ctrl + Shift + Enter)
# (Shortcut to run line Ctrl + Enter)
#Assignments
#(Shortcut is Alt + -)
A <- 50
A
#Concatenation
B <- c(1,2,3)
B
#Quick list
C <- c(-10:10,2) #Does -10 to 10 then adds a 2 as last element
C
#Repetition
y <- c(2:4)
y
rep(y,3) #Repeats y 3 times, like c(y,y,y)
rep(y,times=3) #Same as previous
rep(y,each=3) #Repeats y each element 3 times
x <- rep(100:1,c(100:1)) #Repeats 100 to 1, 100 rep 100 times, 99 rep 99 times....1 rep 1 time
#Sequencing
D <- c(seq(-10,10,5),"A") #Sequence from -10 to 10 by 5 and add string A
D
#List Vars
ls() #shows all defined vars
rm(D) #removes var D from list of vars
ls()
#rm(list=ls()) #removes all vars
#Finding NA
z <- c(1,NA,2,NA,3,4,5)
z
is.na(z)  #Returns a Boolean vector on which is NA, True for Yes
sum(is.na(z))  #Counts how many NAs in z
rm(list=ls())
ct <- c("jap","kor","sin","kor","jap","sin","sin") #Make a list
class(ct)  #Class is characters
fct <- factor(ct) #Turn the items into factors
fct    #See the item as well as levels of factor
levels(fct)  #See the headers/levels for the factors
#fct <- factor(fct, levels=c("jap","kor")) #Filter the levels of interest
#fct
summary(fct)  #See the headers/levels and how many items corr to them
#Similar to pivot table, count items
table(fct)    #Returns same as summary
#Converting Class of Factors
X <- factor(c(4,5,6,6,4))
X <- as.character(X)  #Need to convert to character before numeric
X
X <- as.numeric(X)
X
summary(X)
income <- c(500,1000,4000,1244,3400,2000,5000)
mean(income)
tapply(income,fct,mean)
#tapply format(data, a list of factors same length),function)
med <- data.frame(patient=1:100, age=rnorm(100, mean=60,sd=12),treatment=gl(4,25,labels=c("treatment","control","new","old")))
#Creates a dataframe of 100 patients, with age being random normally distributed, with treatment (general label) 4 labels of 25
med
tapply(med$age,med$treatment,mean)
#Find mean of age sorted by treatment type
g <- matrix(c(1,2,3,4),c(2,2),byrow = T)
g
z <- 1:50
dim(z) <- c(5,2,6) #5 rows, 2 columns, 5 tables
dim(z) <- c(5,2,10) #5 rows, 2 columns, 5 tables
z <- 1:50
dim(z) <- c(5,2,10) #5 rows, 2 columns, 5 tables
dim(z) <- c(5,1,10) #5 rows, 2 columns, 5 tables
z <- 1:50
dim(z) <- c(5,1,10) #5 rows, 2 columns, 5 tables
z
dim(z) <- c(5,2,5) #5 rows, 2 columns, 5 tables
z
z
#can store more than 2 dimmensions
a <- array(3:8,c(3,2))  #data then dim, 3-8 sorted into 3 rows 2 columns
a
#class of matrix and array returns "matrix" & "array"
z <- 1:50
dim(z) <- c(5,2,5) #5 rows, 2 columns, 5 tables
z
class(z)  #class now only returns "array", matrix can only go max of 2D
# (Shortcut to run chunk Ctrl + Shift + Enter)
# (Shortcut to run line Ctrl + Enter)
#Assignments
#(Shortcut is Alt + -)
A <- 50
A
#Concatenation
B <- c(1,2,3)
B
#Quick list
C <- c(-10:10,2) #Does -10 to 10 then adds a 2 as last element
C
#Repetition
y <- c(2:4)
y
rep(y,3) #Repeats y 3 times, like c(y,y,y)
rep(y,times=3) #Same as previous
rep(y,each=3) #Repeats y each element 3 times
x <- rep(100:1,c(100:1)) #Repeats 100 to 1, 100 rep 100 times, 99 rep 99 times....1 rep 1 time
#Sequencing
D <- c(seq(-10,10,5),"A") #Sequence from -10 to 10 by 5 and add string A
D
#List Vars
ls() #shows all defined vars
rm(D) #removes var D from list of vars
ls()
#rm(list=ls()) #removes all vars
#Finding NA
z <- c(1,NA,2,NA,3,4,5)
z
is.na(z)  #Returns a Boolean vector on which is NA, True for Yes
sum(is.na(z))  #Counts how many NAs in z
exp(A)
1/(A)
A^3
y <- A+17
y
#works on vectors as well
exp(B)
B*100
#Finding max and min of Vector
B
min(B)    #returns min value in B
max(B)    #returns max value in B
which.max(B)    #returns position of max element in B
B <- c(B,1)   #added a min to test multiple min returns
B
which(B==min(B))    #returns all the positions of min element in B
#Finding max and min of many vectors
max(B,C)
pmax(B,C) #parallel max (E.g. compares B[1] with C[1] and returns max)
C
sum(C)    #sum all elements in C
which(C==0)  #11
New_C <- C[-11]   #Assign C without the 11th element to C, minus sign removes element
New_C    #Print new C
prod(New_C)   #multiply all elements in C
mean(New_C)   #find the mean of C
sd(New_C)   #find standard deviation of C
summary(New_C) #Quartiles of New_C
#Classes
#Integer
z <- 0:9
z
class(z)
#Character
z1 <- c("a","b")
z1
class(z1)
w <- as.character(z)  #turns z integers into characters
w
#Class conversion
as.integer(w)   #turns characters back to integer
as.logical(c(5,0))  #Returns True and false, T if !=0, F if ==0
z>1  #Checks if each element is greater than 1, returns boolean
as.numeric(c(z>1))  #Checks if each element is greater than 1, returns 1 & 0, 1 for T, 0 for False
#Multiple class types in a list
t <- c(2,"a")  #Store an integer and a character
t
class(t)    #Returns Character
ct <- c("jap","kor","sin","kor","jap","sin","sin") #Make a list
class(ct)  #Class is characters
fct <- factor(ct) #Turn the items into factors
fct    #See the item as well as levels of factor
levels(fct)  #See the headers/levels for the factors
#fct <- factor(fct, levels=c("jap","kor")) #Filter the levels of interest
#fct
summary(fct)  #See the headers/levels and how many items corr to them
#Similar to pivot table, count items
table(fct)    #Returns same as summary
#Converting Class of Factors
X <- factor(c(4,5,6,6,4))
X <- as.character(X)  #Need to convert to character before numeric
X
X <- as.numeric(X)
X
summary(X)
income <- c(500,1000,4000,1244,3400,2000,5000)
mean(income)
tapply(income,fct,mean)
#tapply format(data, a list of factors same length),function)
med <- data.frame(patient=1:100, age=rnorm(100, mean=60,sd=12),treatment=gl(4,25,labels=c("treatment","control","new","old")))
#Creates a dataframe of 100 patients, with age being random normally distributed, with treatment (general label) 4 labels of 25
med
tapply(med$age,med$treatment,mean)
#Find mean of age sorted by treatment type
r <- matrix(c(3,4,5,6,7,8),nrow=3,byrow=F)
#fill up matrix with 3 rows, sort them by column
rownames(r) <- c("A","B","C")  #name rows and col
colnames(r) <- c("1","2")
r
r[3,2] #row 3 column 2
r[5]  #element 5 by columns, counting is done column down
r[1,]  #r row 1
r[,2]  #r column 2
R <- matrix(c(3,4,5,6,7,8),nrow=3,byrow=T)
#fill up matrix sorted by rows
R
g <- matrix(c(1,2,3,4),c(2,2),byrow = T)  #indicate dimension of matrix with a list
g
#Matrix can only store 2 dimmensions
celg <- data.frame(names=c("Obama","serena"), age=c(58,39), children=c(2,1))
celg
celg$names
class(celg)
class(celg$age)  #returns numeric instead of data.frame
table(celg$age==58)   #Check how many people in dataframe is of age 58
table(celg$age<60)
c=subset(celg,celg$age<40)  #filters out age >40 from the data
c
c
data(mtcars)
dim(mtcars)
mtcars[33,] <- c(NA)
mtcars
#Column delete
NAobject <- colnames(mtcars)[apply(is.na(mtcars),2,any)]
#Remove columns with NA value, not removing cars, 2 indicates columns
mtcars
#Remove columns with NA value, not removing cars, 2 indicates columns
NAobject
